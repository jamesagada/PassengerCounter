/**
    PCN (Passenger CouNter)
    Purpose: Creating a computer vision system that counts passengers entering/exiting a door in a transportation environment

    @author Mattia Dal Ben
    @version 1.0 23/02/2017

*/

#include <iostream>
#include <string>
#include <chrono>

#include <opencv2/opencv.hpp>

#include "passenger.cpp"

using namespace cv;
using namespace std;
using namespace std::chrono;

// The XCOMPILER uses a different OpenCV version from my main machine
// so I ended up splitting the code using this constant

// Constants
#define MAXRGBVAL 255

#define RED   Scalar(0,0,255)
#define BLUE  Scalar(255,0,0)
#define GREEN Scalar(0,255,0)
#define WHITE Scalar(255,255,255)

// Calibration starting values
#define BACKGROUN_SUB_THRESHOLD 50
#define THRESHOLD 180
#define BLUR_KSIZE 40
#define ERODE_AMOUNT 3
#define DILATE_AMOUNT 11

#define AREA_MIN 7000     // This depends on the camera distance from the passengers

#define X_NEAR 100
#define Y_NEAR 100

#define MAX_PASSENGER_AGE 30 // 30 FPS * 3 seconds (HP: 30fps camera)

void displayHelp()
{
    cout << "HELP Avalable modes:\n";
    cout << "              - Without arguments: it opens the default webcam and captures the input stream.\n";
    cout << "-c            - Calibration mode: it opens the default webcam and display calibration trackbars.\n";
    cout << "-i            - Intermediate steps: it opens the default webcam and display intermediate image processing steps.\n";
    cout << "-f <filename> - Input video: it opens the file passed as argument and captures the stream.\n";
    cout << "-h            - Display help.\n";
    return;
}

int main(int argc, char * argv[])
{
    bool calibrationOn = false;
    bool intermediateStep = false;
    
    VideoCapture cap;

    // Calibration
    int whiteThreshold = THRESHOLD;
    int dilateAmount = DILATE_AMOUNT;
    int erodeAmount = ERODE_AMOUNT;
    int blur_ksize = BLUR_KSIZE;

    int areaMin = AREA_MIN;

    int xNear = X_NEAR;
    int yNear = Y_NEAR;

    int maxPassengerAge = MAX_PASSENGER_AGE;

    // Passenger counters
    int cnt_in  = 0;
    int cnt_out = 0;

    // Passengers tracker
    int pid = 0;
    vector<Passenger> passengers;

    // Streams
    Mat frame;       //input stream
    Mat fgMaskMOG2;  //fg mask generated by MOG2 method
    Mat morphTrans;  //fgMaskMOG2 after morphological transformations

    // Contours variables
    vector<vector<Point> > contours;
    vector<Vec4i> hierarchy;

    // Background subtraction variables
    Ptr<BackgroundSubtractor> pMOG2; //MOG2 Background subtractor

    int history = 1000;
    double varThreshold = BACKGROUN_SUB_THRESHOLD;
    bool detectShadows = false;
    pMOG2 = createBackgroundSubtractorMOG2(history, varThreshold, detectShadows);

    // Execution time
    duration<double> loopTime;
    bool firstLoop = true;

    // --INITIALIZE VIDEOCAPTURE
    if(argc == 1)
    {
        // Open the default camera using default API
        cap.open(0);

        if(!cap.isOpened())
        {
            cerr << "ERROR! Unable to open camera\n";
            return -1;
        }
    }
    else if(argc >= 2)
    {
        if(!strcmp(argv[1], "-c"))
        {
            calibrationOn = true;

            // Open the default camera using default API
            cap.open(0);

            if(!cap.isOpened())
            {
                cerr << "ERROR! Unable to open camera\n";
                return -1;
            }
        }
        else if(!strcmp(argv[1], "-i"))
        {
            intermediateStep = true;

            // Open the default camera using default API
            cap.open(0);

            if(!cap.isOpened())
            {
                cerr << "ERROR! Unable to open camera\n";
                return -1;
            }
        }
        else if(!strcmp(argv[1], "-f"))
        {
            // Open the video file passed as argument
            cap.open(argv[2]);

            if(!cap.isOpened())
            {
                cerr << "ERROR! Unable to open video\n";
                return -1;
            }
        }
        else if(!strcmp(argv[1], "-h"))
        {
            // --HELP
            displayHelp();
            return 0;
        }
    }
    else
    {
        // --HELP
        displayHelp();
        return 0;
    }

    // --SETUP WINDOWS
    namedWindow("Live",WINDOW_AUTOSIZE);

    if(intermediateStep)
    {
        namedWindow("BackgroundSubtraction", WINDOW_AUTOSIZE);
        namedWindow("MorphologicalTransfor", WINDOW_AUTOSIZE);
    }

    // --GRAB AND WRITE LOOP
    cout << "Start grabbing loop\n";

    while(1)
    {
        // Wait for a frame from camera/video and store it into frame
        bool bSuccess = cap.read(frame);

        // Check for errors
        if (!bSuccess) //if not success, break loop
        {
            cout << "ERROR! Cannot read the frame from video file\n";
            break;
        }

        if (frame.empty()) {
            cerr << "ERROR! Blank frame grabbed\n";
            break;
        }

        //-- PERFORMANCE ESTMATION
        high_resolution_clock::time_point t1 = high_resolution_clock::now(); //START
        
        // Horizontal line     
        line( frame,
              // Vertical line
              //Point(frame.cols/2,0),            //Starting point of the line
              //Point(frame.cols/2,frame.rows),   //Ending point of the line  
              // Horizontal line
              Point(0,frame.rows/2),            //Starting point of the line
              Point(frame.cols,frame.rows/2),   //Ending point of the line
              RED,                              //Color
              2,                                //Thickness
              8);                               //Linetype

	    // --BACKGROUND SUBTRACTION
        pMOG2->apply(frame, fgMaskMOG2, 0.1);

        // --MORPHOLOGICAL TRANSFORMATION
        // Threshold the image
        threshold(fgMaskMOG2, morphTrans, whiteThreshold, MAXRGBVAL, THRESH_BINARY);

        // Eroding
        erode(morphTrans,morphTrans, Mat(Size(erodeAmount,erodeAmount), CV_8UC1));

        // Dilating
        dilate(morphTrans,morphTrans, Mat(Size(dilateAmount,dilateAmount), CV_8UC1));

        // Blurring the image
        blur(morphTrans,morphTrans, Size(blur_ksize,blur_ksize));

        // --FINDING CONTOURS
        findContours(morphTrans, contours, hierarchy, RETR_EXTERNAL, CHAIN_APPROX_NONE);

        // For every detected object
        for(int idx = 0 ; idx >= 0; idx = hierarchy[idx][0] )
        {
            // Draw contours for every detected object
            // drawContours( frame, contours, idx, Scalar(0,255,0), 2, 8, hierarchy, 0, Point(0,0) );

            // -- AREA
            // Calculating area
            double area1 = contourArea(contours[idx]);

            // Approximate area
            // vector<Point> approx;
            // approxPolyDP(contours[idx], approx, 5, true);
            // double area1 = contourArea(approx);

            // If calculated area is big enough begin tracking the object
            if(area1 > areaMin)
            {
                // --TRACKING
                // Getting mass center
                Moments M = moments(contours[idx]);
                Point2f mc = Point2f( M.m10/M.m00 , M.m01/M.m00 );

                // Getting bounding rectangle
                Rect br = boundingRect(contours[idx]);

                // Drawing mass center and bounding rectangle
                rectangle( frame, br.tl(), br.br(), GREEN, 2, 8, 0 );
                circle( frame, mc, 5, RED, 2, 8, 0 );

                // --PASSENGERS DB UPDATE
                bool newPassenger = true;
                for(unsigned int i = 0; i < passengers.size(); i++)
                {
                    // If the passenger is near a known passenger assume they are the same one
                    if( abs(mc.x - passengers[i].getX()) <= xNear &&
                        abs(mc.y - passengers[i].getY()) <= yNear )
                    {
                        // Update coordinates
                        newPassenger = false;
                        passengers[i].updateCoords(mc);

                        // --COUNTER
                        if(passengers[i].getTracks().size() > 2)
                        {
                            // Left to right
                            // if(passengers[i].getLastPoint().x < frame.cols/2 &&
                            //    passengers[i].getCurrentPoint().x > frame.cols/2)

                            // Up to down
                            if( (passengers[i].getLastPoint().y < frame.rows/2 && passengers[i].getCurrentPoint().y >= frame.rows/2) ||
                                (passengers[i].getLastPoint().y <= frame.rows/2 && passengers[i].getCurrentPoint().y > frame.rows/2) )
                            {
                                cnt_out++;

                                cout << "ID: " << passengers[i].getPid() << " crossed going U to D.\n";

                                // Visual feedback
                                circle(frame, Point(frame.cols - 20, 20), 8, RED, CV_FILLED);
                            }

                            // Right to left
                            // if(passengers[i].getLastPoint().x > frame.cols/2 &&
                            //    passengers[i].getCurrentPoint().x < frame.cols/2)

                            // Down to up
                            if( (passengers[i].getLastPoint().y > frame.rows/2 && passengers[i].getCurrentPoint().y <= frame.rows/2) ||
                                (passengers[i].getLastPoint().y >= frame.rows/2 && passengers[i].getCurrentPoint().y < frame.rows/2) )
                            {
                                cnt_in++;

                                cout << "ID: " << passengers[i].getPid() << " crossed going D to U.\n";

                                // Visual feedback
                                circle(frame, Point(frame.cols - 20, 20), 8, GREEN, CV_FILLED);
                            }

                        }

                        break;
                    }
                }

                // If wasn't near any known object is a new passenger
                if(newPassenger)
                {
                    Passenger p(pid, mc);
                    passengers.push_back(p);
                    pid++;
                }
            }
        }

        // For every passenger in passengers DB
        for(unsigned int i = 0; i < passengers.size(); i++)
        {
            // -- DRAWING PASSENGER TRAJECTORIES
            if(passengers[i].getTracks().size() > 2)
            {
                polylines(frame, passengers[i].getTracks(), false, passengers[i].getTrackColor(),2);
                //putText(frame, "Pid: " + to_string(passengers[i].getPid()), passengers[i].getCenter(), FONT_HERSHEY_SIMPLEX, 0.5, passengers[i].getTrackColor(), 2);
            }

            // --UPDATE PASSENGER STATS
            // Updating age
            passengers[i].updateAge();

            // Removing older passengers
            // NB: The age depends on the FPS that the camera is capturing!
            if(passengers[i].getAge() > maxPassengerAge)
            {
                passengers.erase(passengers.begin() +i);
            }
        }

        // --PRINTING INFORMATION
        putText(frame, "Count IN: " + to_string(cnt_in), Point(0,frame.rows - 10) , FONT_HERSHEY_SIMPLEX, 1, WHITE, 2);
        putText(frame, "Count OUT: " + to_string(cnt_out), Point(frame.cols - 310,frame.rows - 10) , FONT_HERSHEY_SIMPLEX, 1, WHITE, 2);

        // --CALIBRATION TRACKBARS
        if(calibrationOn)
        {
            createTrackbar("Threshold", "Live", &whiteThreshold, 255);
            createTrackbar("Blur", "Live", &blur_ksize, 100);
            createTrackbar("Erode", "Live", &erodeAmount, 25);
            createTrackbar("Dilate", "Live", &dilateAmount, 25);

            createTrackbar("xNear", "Live", &xNear, 250);
            createTrackbar("yNear", "Live", &yNear, 250);

            createTrackbar("Area min", "Live", &areaMin, 10000);

            createTrackbar("Passenger age", "Live", &maxPassengerAge, 300);
        }

        // Show videos
        imshow("Live",frame);

        if(intermediateStep)
        {
            imshow("BackgroundSubtraction", fgMaskMOG2);
            imshow("MorphologicalTransfor", morphTrans);
        }

        // --PERFORMANCE ESTMATION
        high_resolution_clock::time_point t2 = high_resolution_clock::now(); //STOP

        if(firstLoop)
            loopTime = duration_cast<duration<double>>(t2 - t1);
        else
        {
            loopTime += duration_cast<duration<double>>(t2 - t1);
            loopTime = loopTime/2;
        }

        if(waitKey(30) == 27) //wait for 'esc' key press for 30 ms. If 'esc' key is pressed, break loop
        {
            cout << "esc key is pressed by user" << endl; 
            break;
        }

        firstLoop = false;
    }

    cout << "Execution time:\n";
    cout << "Loop: " << loopTime.count() << " seconds\n";

    destroyAllWindows(); 
    return 0;
}

